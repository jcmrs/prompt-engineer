You are Jules, the Coding AI Agent for github.com/jcmrs/prompt-engineer. This message is the full, canonical specification for implementing the Prompt Engineering Agent (PEA). Use branch copilot/scaffoldinitial-pea. This message is the single source-of-truth. Implement everything in this message exactly, and commit tested, formatted code and docs. If anything cannot be completed due to environment or permission limits, add a top-level TODO in the PR explaining what could not be run and why.

High-level purpose

Build a local-first Prompt Engineering Agent (PEA) that:
Is Windows-first (target Windows 11), desktop UI (Flutter) and a supervised local backend (Go) bundled together.
Uses the Gemini CLI as the single AI provider (OAuth via local CLI only; absolutely no API keys anywhere).
Uses gemini-2.5-flash as the golden-path model and supports gemini-2.5-pro.
Provides a rich streaming chat UI, conversation management, attachments (markdown, text, PNG), prompt library, search, versioned prompt artifacts, an iterative prompt-engine loop (generate→execute→refine→verify→export).
Is privacy-first: default redaction, optional --no-store, no third-party upload unless explicitly opt-in.
Hard constraints (must be enforced)

NO API KEYS or static secrets anywhere in the repo or CI.
Authentication: exclusively via the user’s local Gemini CLI OAuth flow. The server should only attempt to use real Gemini CLI when PEA_GEMINI_MOCK is NOT set and the CLI is authenticated.
The repo must contain the full original human prompt in docs/jules_prompt.txt.
CI must only use the built-in gemini-mock (PEA_GEMINI_MOCK=true). Real Gemini CLI must never be invoked in CI.
All persisted artifacts must include provenance: timestamp, model_name, model_config, prompt_version, run_id, input, output and scores.
Provide an opt-in --no-store flag and a --no-redact option only for local debugging (documented).
Deliverables (what Jules must produce)

Complete code changes on branch copilot/scaffoldinitial-pea:
Go server (cmd/pea) including CLI: check-auth, serve, run, export.
internal/gemini wrapper with robust mock and real-mode handling.
scripts/gemini-mock (portable Go program).
storage layer: SQLite schema and migrations (InitDB).
server: HTTP REST + WebSocket streaming endpoints.
engine: iterative prompt-engine scaffold that can run N candidates and evaluate (initial implementation can be partial but must be functional with mock).
evaluator: scaffolding with at least 3 scorers (structure, simple unit test harness, safety heuristic).
client/flutter_app skeleton that connects to WebSocket and renders streaming tokens; includes conversation list and prompt library skeleton.
templates/ with at least 5 example templates (YAML).
tests: unit tests and integration tests that run against gemini-mock (integration tests must be self-contained).
.github/workflows/ci.yml updated to run tests with PEA_GEMINI_MOCK=true and either start the server in-process or run in-process tests.
docs/jules_prompt.txt (contains the entire original human prompt that was posted as a PR comment).
PR updates:
Update the draft PR (copilot/scaffoldinitial-pea) with commits described above.
Update PR body to include a short “What changed” and a link to docs/jules_prompt.txt.
If CI passes, mark PR as ready for review (remove draft). If CI fails, keep as draft and include plain-English failure summary + exact next steps.
Tests must pass locally and in CI with mock (unit + integration).
README improved with Windows-first quickstart and explicit Gemini CLI auth instructions.
Repo layout (exact)

cmd/pea/main.go
internal/
gemini/wrapper.go
engine/engine.go
evaluator/evaluator.go
storage/db.go
server/server.go
supervisor/supervisor.go (process control)
models/models.go
utils/redact.go
utils/attachments.go
scripts/gemini-mock/main.go (small Go program)
client/flutter_app/lib/... (Flutter skeleton)
templates/*.yaml
tests/go/unit/... and tests/go/integration/...
docs/jules_prompt.txt
.github/workflows/ci.yml
README.md
APIs & WebSocket contract (exact JSON frame contracts)

REST (JSON)
GET /health -> 200 {"status":"ok","version":"<commit-sha>"}
GET /auth/check -> 200 {"authenticated": true|false, "message": "..."}
POST /conversations -> body { "title" } -> returns conversation object
GET /conversations -> list
GET /conversations/{id} -> conversation + messages
POST /conversations/{id}/messages -> body: { "role":"user", "text":"...", "attachments":[ids], "prompt_template_id":null|string, "run_mode":"single"|"iterative", "no_store":bool } returns { "run_id": [...]
POST /runs -> start iterative run: { "template_id":"...", "n_candidates":5, "model":"gemini-2.5-flash", "max_iterations":3, "no_store":false } returns run_id
GET /runs/{id} -> returns artifacts, evaluations
POST /attachments -> multipart upload -> returns attachment_id + text_extract (optional)
WebSocket streaming:
ws://localhost:{port}/ws/run/{run_id}?token={ephemeral_token}
Event frames (line-delimited JSON):
token: { "type":"token", "data":"...", "chunk_index":int, "is_final": false }
meta: { "type":"meta", "model":"gemini-2.5-flash", "usage":{"tokens":123} }
progress: { "type":"progress", "percent": 0-100 }
final: { "type":"final", "content":"...", "metrics": {...} }
error: { "type":"error", "code":"TIMEOUT"|"MODEL_ERROR", "message":"..." }
Gemini wrapper behavior (detailed, exact)

Create internal/gemini/wrapper.go with:
type Wrapper interface { CheckAuth(ctx) error; RunChatStreaming(ctx, model, input, settings, onToken) (finalResult, error); Embeddings(ctx context.Context, text string) ([]float32, error) (optional) }
NewWrapperFromEnv() reads PEA_GEMINI_MOCK env var.
CheckAuth(ctx): if Mock -> return nil. Else:
Try gemini whoami --format=json. If command fails or unknown, fallback to gemini auth status --format=json (if available). If neither available, fallback to a safe chat test: echo 'ping' | gemini chat[...]
RunChatStreaming(ctx,...):
If Mock -> use deterministic in-memory token emission via callback (no external process spawn).
If Real -> spawn gemini chat with exec.CommandContext and:
Configure process group (Setpgid) so kills terminate entire group (important for Windows use appropriate syscall equivalent).
Write input to stdin.
If CLI supports streaming JSON frames, parse frames line-by-line and call onToken per token; else fallback to reading final JSON result and call onToken with substrings to simulate streaming and retur[...]
Implement context cancellation: on ctx cancellation kill process group and return error.
Handle timeouts and retries (configurable in settings).
Add TODO comments: streaming parser improvement and fallback notes.
Mock (scripts/gemini-mock/main.go)

Implement as simple Go program: prints JSON frames line-by-line with slight sleeps to simulate streaming, then prints final frame. Buildable on CI.
Storage & DB schema (exact)

SQLite file path configurable by env PEA_DB_PATH (default: %APPDATA%/pea on Windows or ./data for dev).
Tables:
conversations(id TEXT PK, title TEXT, created_at TEXT, updated_at TEXT)
messages(id TEXT PK, conversation_id TEXT, role TEXT, content TEXT, attachments JSON, model TEXT, model_config JSON, prompt_version TEXT, created_at TEXT)
prompts(id TEXT PK, version TEXT, author TEXT, intent TEXT, description TEXT, prompt_text TEXT, settings JSON, examples JSON, created_at TEXT)
runs(id TEXT PK, prompt_id TEXT, model TEXT, settings JSON, status TEXT, created_at TEXT)
evaluations(id TEXT PK, run_id TEXT, metrics JSON, created_at TEXT)
attachments(id TEXT PK, filename TEXT, path TEXT, mimetype TEXT, text_extract TEXT, created_at TEXT)
audit_logs(id TEXT PK, action TEXT, actor TEXT, details JSON, created_at TEXT)
Add FTS5 virtual table for text search (prompts and messages).
Each stored row must include provenance (model, model_config, prompt_version, run_id, timestamp).
Prompt template format (YAML)

Schema fields: id, version, created_at, author, intent, description, model_preferences { primary: gemini-2.5-flash, fallback: gemini-2.5-pro }, prompt_text (templated), positive_examples[], negative_e[...]
Provide 5 example templates in templates/.
Iterative engine (implementation guidance)

Implement a coordinator that:
Intake: parse user intent and constraints.
Draft generation: produce N candidate prompts (seeded by templates + small programmatic variations: role framing, constraints tightening, examples injection).
Execution: run candidates against model (mock in tests).
Evaluation: score outputs via evaluator plugins.
Refinement: top-k refinement pass (ask model to rewrite prompt to address weaknesses).
Verification: re-run refined prompts and select final.
Export: produce artifacts and persist them.
For this PR: implement a minimal functional loop using the mock so run returns candidates and scores.
Evaluator (must have at least 3 scorers)

Structure scorer: checks for required JSON or markdown headings using regex or JSON parse.
Unit-test harness (for code tasks): runs provided pytest or node tests in sandboxed temp dir (for Windows keep careful about sandboxing; for this PR, run only small deterministic tests).
Safety heuristic: redact patterns (emails, keys) and a banned-words list; produce a toxicity_penalty.
Composite score: weighted sum (configurable).
Testing / CI (exact requirements)

Add go.mod in repo root: module github.com/jcmrs/prompt-engineer and include required deps (gorilla mux/websocket, mattn/go-sqlite3).
Unit tests: Go unit tests for wrapper, server handlers (use httptest), storage (use temp DB), engine (mocked).
Integration tests: tests/go/integration should start server.NewServer() in-process (call server.NewServer() in goroutine with PEA_GEMINI_MOCK=true), wait for /health, connect to ws/run/demo-run and assert token f[...]
CI workflow (.github/workflows/ci.yml): two jobs:
go-tests: setup go, go mod download, go vet, go test ./...
integration-mock: setup go, set env PEA_GEMINI_MOCK=true, run go test ./tests/go/integration -v (the tests start in-process server so CI does not need to spawn background processes).
Do NOT invoke real gemini in CI.
Security & privacy

Default storage redacts emails, API-like tokens, credit card patterns; store redacted_content and (if user opts in) encrypted full_content using local passphrase (left as TODO for this PR; include fla[...]
Provide CLI flag --no-store for ephemeral runs.
Document privacy tradeoffs in README.
Windows packaging & build

Provide goreleaser/build scripts but do not require signing in this PR. Document manual steps for bundling Go server + Flutter binary.
Flutter app must be a skeleton; packaging complex installers is out of scope for this PR.
What to do immediately in the branch (exact step-by-step for Jules)

Add docs/jules_prompt.txt containing the entire original human prompt (the text the human posted as a PR comment). If it’s very long, split and name sequentially (docs/jules_prompt_part1.txt etc.). [...]
Add go.mod with module github.com/jcmrs/prompt-engineer and the required dependencies. Run go mod tidy. Commit: "fix: add go.mod & tidy".
Update internal/gemini/wrapper.go to implement the robustness, mock and TODOs described above. Ensure mock-mode uses in-memory emission and does not spawn external process. Commit: "fix(gemini): robus[...]
Update tests/go/integration/test_basic_run.go to start server.NewServer() inside Test (in-process) using a temp DB directory and set os.Setenv("PEA_GEMINI_MOCK","true") inside the test. Commit: "test([...]
Update .github/workflows/ci.yml to run unit tests and integration-mock using PEA_GEMINI_MOCK and to run go vet/gofmt. Commit: "ci: run unit + integration tests with mock".
Ensure scripts/gemini-mock/main.go compiles (go build ./scripts/gemini-mock). Commit: "chore(mock): ensure gemini-mock buildable".
Run gofmt -w . and go vet ./.... Fix any compile/test failures. Commit fixes as needed.
Update README.md with Windows-first quickstart and explicit gemini auth instructions and how to run tests locally (one-liners).
Update PR body to include a short "What changed" list and link to docs/jules_prompt.txt.
Run tests (go test ./... and go test ./tests/go/integration -v); if tests pass, remove draft status on PR and add a plain-English summary for the non-technical user (see below).
Human-friendly summary (to include in PR body)

Plain English paragraph: "I fixed the scaffold so that unit and integration tests use a deterministic local mock. I added go.mod, made integration tests start the server in-process (so CI does not nee[...]
Acceptance checklist:
 go test ./... passes
 integration tests pass with PEA_GEMINI_MOCK=true
 docs/jules_prompt.txt present
 README updated with simple Windows quickstart
If you (Jules) cannot complete a step due to environment or permission limitations:

Do NOT fail silently.
Add a single top-level TODO in the PR body like: TODO: I could not run go mod tidy or push commits because [reason]. Please run: <exact command> locally and paste output here.
If any test fails and you cannot fix it programmatically, include failing test output and a one-line explanation in plain English and a suggested command to run locally.
Commit and PR conventions

Use clear conventional commit messages.
Keep changes small and focused; prefer multiple commits with clear messages over one large commit.
Run gofmt -w . before committing.
Add TODO comments for future work and tag them with [TODO-JULES] in code.
Post-run: what you must do and then stop

After making all commits and updates, run tests. If tests pass, mark PR ready for review (remove draft). If tests fail, keep PR draft and add plain-English failure summary.
Post a single short comment on the PR tagging @jcmrs containing:
one-sentence summary in plain English,
link to docs/jules_prompt.txt,
instructions for a single command the human can run locally to validate (one-liner),
explicit note: "I did not add any API keys or attempt to run real Gemini in CI."
Finish there and wait for human next instruction.
